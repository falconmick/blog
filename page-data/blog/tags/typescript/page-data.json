{"componentChunkName":"component---packages-gatsby-theme-blog-core-src-templates-tag-query-js","path":"/blog/tags/typescript/","result":{"data":{"allPost":{"posts":[{"id":"9496939d-e30d-50dd-b3f6-15454502f69d","title":"Angular 2 - Polymorphic Component Container using ContentChildren","date":"October 11, 2016","excerpt":"Legacy blog post from blogger platform about Angular 2","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Angular 2 - Polymorphic Component Container using ContentChildren\",\n  \"date\": \"2016-10-11T00:00:00.000Z\",\n  \"excerpt\": \"Legacy blog post from blogger platform about Angular 2\",\n  \"image\": \"./angular.svg\",\n  \"tags\": [\"angular\", \"javascript\", \"typescript\", \"legacy-blog-post\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This post is outdated and only exists for historical reasons\")), mdx(\"p\", null, \"As I do a deep dive into Angular 2 I've been finding some amazing features,\\none which really stands out being the Decorator \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://angular.io/api/core/ContentChildren\"\n  }, \"ContentChildren\"), \".\\nContentChildren allows a component to access it's children components\\nwhich are placed between it's selector. An example of such a setup is as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-html\"\n  }, \"<parent>\\n  <child></child>\\n  <child></child>\\n</parent>\\n\")), mdx(\"p\", null, \"now inside of the parent's component it can define the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"@ContentChildren(ChildComponent) editors: QueryList<ChildComponent>;\\n\\nngAfterViewInit() {\\n  let myChildComponents = this.editors.toArray();\\n}\\n\")), mdx(\"p\", null, \"NOTE: you cannot access the child components inside of ngOnInit as the\\nchild components have not become available yet. ContentChildren and\\nQueryList are both found inside of @angular/core.\"), mdx(\"p\", null, \"The benefit of ContentChildren over the traditional AngularJs's transclude\\nis that the child component need not know about the parent component.\\nThis is great because a common design pattern is top down (example a tab component).\"), mdx(\"p\", null, \"The real hidden gem here though is creating a system where you can have an\\nabstract base class for your child components. Through doing so you can achieve a\\npolymorphic system which lets you combine multiple like components with a base class.\"), mdx(\"p\", null, \"Lets say for example, you have a dropdown of question types that a user can\\nchoose to answer with. You could either couple all of the editors and have\\nthem hard coded into the component that produces this part of your website,\\nOR you could have a container ccomponent which accepts any number of different\\neditors which are just placed in and magically work! I much prefer magic,\\nso lets have a look at the markup that could achieve this\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-html\"\n  }, \"<question-editor>\\n  <foo-editor></foo-editor>\\n  <bar-editor></bar-editor>\\n</question-editor>\\n\")), mdx(\"p\", null, \"the contents of question-editor don't matter yet, so lets have a think of what\\ninformation we would require from each of our editors (foo and bar).\\nfirst we would need to be able to hide then when they are in-active,\\nthen get some sort of human friendly name and finally get the value\\nthat the form has extracted from the user. this contract could be\\nforfilled with the following abstract class\\n(using abstract class over interface as interfaces are compile time only,\\nand I need something injectable!)\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export abstract class BaseEditor {\\n  constructor(private privateEditorName: string, public isSelected: boolean = false) {}\\n  get editorName(): string {\\n    return this.privateEditorName;\\n  }\\n  public value: string;\\n}\\n\")), mdx(\"p\", null, \"as you can see, this base class exposes a getter for the editorName,\\nthe value and also isSelected (used to toggle visibility)\"), mdx(\"p\", null, \"A class would then implement this base class like so\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import { Component, forwardRef } from '@angular/core';\\nimport { BaseEditor } from 'app/editor/base-editor.ts';\\n\\n@Component({\\n  selector: 'bar-editor',\\n  template: `\\n  <div style=\\\"color: blue\\\" *ngIf=\\\"isSelected\\\">\\n    <p>bar editor</p>\\n    <input [(ngModel)]=\\\"value\\\">\\n  </div>\\n  `,\\n  providers: [{provide: BaseEditor, useExisting: forwardRef(() => BarEditorComponent)}]\\n})\\nexport class BarEditorComponent extends BaseEditor {\\n  constructor() {\\n    super('bar editor', false)\\n  }\\n}\\n\")), mdx(\"p\", null, \"as this editor is a test editor, there is no complicated editor logic inside of the component,\\nbut theoretically in a real world situation there would be.\\nWhat makes this editor unique to the foo editor is that it allows the user to enter an\\nanswer via an input field which we can see inside of the template.\"), mdx(\"p\", null, \"The other thing to notice here, is that we are providing the angular\\nDI system an implementation of the BaseEditor through use of the ExistingProvider provider\\n(as seen inside of @Component's providers array). This provider basically tells angular,\\nif somebody asks about BaseEditor, I'm your man! As we are defining this provide at the\\ncomponent level, we don't have to worry about breaking the DI every time we define\\na new editor either as the provide is scoped to this component and under.\"), mdx(\"p\", null, \"next we have a look at the question-editor\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import { Component, OnInit, AfterViewInit, ContentChildren, QueryList, Output, EventEmitter } from '@angular/core'\\nimport { BaseEditor } from 'app/editor/base-editor.ts';\\n\\n@Component({\\n    templateUrl: 'app/editor/editor.component.html', // unfortunatly need full uri\\n    selector: 'question-editor'\\n})\\nexport class EditorComponent implements OnInit, AfterViewInit {\\n  @Output() formValueChange: EventEmitter<string> = new EventEmitter<string>();\\n  @ContentChildren(BaseEditor) editors: QueryList<BaseEditor>;\\n\\n  onQuestionChange(newQuestion: string) {\\n    // reset editors\\n    this.hideAllEditors();\\n    let editorFilter = this.editors.filter(editor => editor.editorName === newQuestion);\\n    let editor = editorFilter[0];\\n\\n    if(editor == null) {\\n      throw new Error(`Cannot find question editor for: ${newQuestion}`)\\n    }\\n\\n    editor.isSelected = true;\\n  }\\n\\n  onClickSubmit() {\\n    let currentEditor = this.editors.filter(editor => editor.isSelected)[0];\\n    console.log(`submitting: ${currentEditor.value}`);\\n    this.formValueChange.emit(currentEditor.value);\\n  }\\n\\n  private hideAllEditors(): void {\\n    this.editors.forEach(editor => {\\n      editor.isSelected = false;\\n    })\\n  }\\n}\\n\")), mdx(\"p\", null, \"the part to take note of is the @ContentChildren. As you can see,\\nwe request all children of this component which have the type of BaseEditor.\\nBoth FooEditor and BarEditor have setup their DI to point all requests for\\nBaseEditor to themselves, so as we scan over the components,\\neach editor is picked upa as a BaseEditor and placed inside the array for editors.\\nThe remainder of the code in the component are used to hide, display and gather\\ninput from the editors.\"), mdx(\"p\", null, \"The html for this component is as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-html\"\n  }, \"<div>\\n  <select (change)=\\\"onQuestionChange($event.target.value)\\\">\\n    <option *ngFor=\\\"let editor of editors\\\" [value]=\\\"editor.editorName\\\">{{ editor.editorName }}</option>\\n  </select>\\n</div>\\n<div>\\n  <ng-content></ng-content>\\n</div>\\n<div>\\n  <button (click)=\\\"onClickSubmit()\\\">submit</button>\\n</div>\\n\")), mdx(\"p\", null, \"as you can see, we are using our list of editors to create options for our select,\\nthen displaying it inside of our component via ng-content.\"), mdx(\"p\", null, \"In summary: @ContentChildren is an amazing new tool for every angular developers utility belt.\\nIt allows for creating top down architectures and with some DI wizardry,\\nit also allows for polymorphic designs to be created!\"), mdx(\"p\", null, \"(no longer) Working example over here on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://plnkr.co/edit/MNU0tn?p=preview&preview\"\n  }, \"Plunker\")));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/blog/2016/10/angular-2-polymorphic-component-container/","tags":["angular","javascript","typescript","legacy-blog-post"],"caption":null,"embeddedImagesLocal":null,"image":{"full":null,"thumbnail":null,"fixed":null,"extension":"svg","publicURL":"/static/5c69e565f1ae6d7717fb3ecd2be004ad/angular.svg"}}]}},"pageContext":{"name":"typescript"}},"staticQueryHashes":["1849085223","4250269005"]}