---
title: How to make a button
date: 2022-03-09
excerpt: Writing a good button for your website doesn't need to be hard, this post will show you the way!
image: ./button.svg
tags: ["css", "design", "html", "--css-variables"]
---

import FinalDemo from './source/final';

It feels like making a reusable button that just works for everything should be easy; but if you have never
made one or if you've never had time thoughtfully build one from scratch they can be a plain and simple pain
to maintain.

To save you from scrolling to the end of the post here is what we are working toward:

<FinalDemo id="full-code-example" />
<br />

If you look at the comments in the css you can see the three important parts to how to design reusable and consistent
buttons that work for any and all HTML elements. Those steps consist of:

1. Normalise the element to look as if it were an un-styled span of text (typically I use inline-block however for display).
2. Apply button styling
3. Apply customisation for individual button (as such as color)

### Step 1: Normalisation

This is the first and most important step in making convincing reusable buttons and also the one that people get
wrong the most, as typically a developer will take a `<button class="cool-button" />` apply some padding + background + border and call
it a day.

This is the wrong approach because what happens 2 days later when that form submitting button that the managers
just loved to pieces now needs to be used to create a link from /categories over to /categories/pop. Well what happens
is the developer will start out with `<a class="cool-button" />` and all of a sudden realise that their button has a weird
color when it's hovered, that it gets an underline and finally that the display is inline instead of an inline block. What
they didn't discover is that once the user goes to that link the button text changes color to unfortunately a color very similar
to their buttons custom styling, of which they never noticed because they were working backwards trying to force an element
that already has pre-existing looks and feels into a class that was never designed for it. What is worse is depending on how this
is done it could even end up making the original button not look right + when we start to use more than one different color
button it can just get super hard to keep bending the unplanned css design to bend to the systems needs.

This is why it's always best to start out with a baseline, that baseline being a normalised span of text with 0 browser
styling and 0 custom styling (aka if you are using tailwind, it's time to apply some additional work to make sure your
button looks as much like plain old boring text as possible.). see what that looks like here:

<StepOneDemo />
<br />

As you can see, now the button and the anchor tag both look identical to the span tag, they are normalised and now ready
to receive the button styling. You might have also noticed "`--btn-color: #FFFFFF`" and also "`color: var(--btn-color);`"
what this is, is the starts to how we apply theming to our buttons, it basically boils down to: "`color: #FFFFFF`" however
we use the css variable --brn-color as a way to allow future styles further down in the stylesheet (and therefore with a higher
precedence to any style with the same specificity as such as .btn) can overwrite it's meaning and thus change the color of the
text.

But why do this in the reset instead of just doing it inside the button styling? It feels pretty redundant doing this work twice!
HOWEVER there is some reason behind this madness, which is not everybody has a shadow dom like I do to render their butons inside of
(maybe you using web components and do?) which means sometimes some pretty nasty styles can pollute the global styling of your
elements. Say for example what if somebody decided to make something like so:

```css
a:hover {
  color: red !important;
}
```

This is such a big deal when it comes to our button (and in general all css, please for the love of all things holy just
stop using !important and start planning out your specificity) because now our button styling must include a fix
for the anchor tags un-normalised look and feel. This is an issue purely because it pollutes the styles of your button and
makes it less and less about the buttons look and feel and more about one version of the buttons look and feel.

By using css variables when we apply our normalisation fix on our anchor tag to fix the above:

```css
.anchor-btn {
  --btn-color: #FFFFFF;
  display: inline-block;
  text-decoration: unset;
  color: var(--btn-color);
}
a.anchor-btn:hover {
  color: var(--btn-color) !important;
}
```

What's also cool about using css variables here is that it also means that when somebody implements a custom button
they don't get the bug where the quick fix for a bad important (as show above) takes precedence over their custom
theme color and thus we automatically get a fixed button in the new color of button without having to write another
fix for the "`!important`" code!

If you are wondering what the "`:root`" thing is at the top, this is just a pseudo selector that selects the root of the
document and defines your css variable globally. Your first gut reaction might be one of shock and horror, we just spent
the last 10 years migrating to esm to get away from global name conflicts, and now we go and start standardising on them! The
concern is correct HOWEVER the general rule of thumb with a best practice, is that as soon as you know why the best
practice of avoiding globals exists (i.e. name clashing) you can feel some form of safety in using them provided you
keep that in mind. This is why we didn't just call our "`--btn-color`" variable "`--color`", as the author of the website
I take ownership of the global css variables and as such I would never allow for any other library to be utilised which
haphazardly defined css variables which were overly generic and in doing so I am left free to use them.

But with all the risks of this global definition of my button's variable what are the gains? Easy, the ability to
customise theming of sections of my dom. Say for example I want to make the sidebar's button text color hot pink?
easy I define the aside like so:

```html
<style>
aside {
  --btn-color: #FF69B4; // or <aside style="--btn-color: #FF69B4;">
}
</style>
<aside>
  Look at my <button class="btn button-btn">HOT PINK</button> button
</aside>
```

You might notice that I don't actually set the cursor to default. This is because I know that I am
100% going to be setting these in the next step so there is literally no point to, thus our button and anchor tags still
have their pointer cursor.

### Step 2: Button styling

Not too much to say about this part but here is the code:

<StepTwoDemo />
<br />

Typically, how the button looks and interacts with hover is more of a design decision per application, but as you can see
here we are setting some of these values with css variables as such as "`--btn-background-color`" and "`--btn-background-color-hover`"
once again this is being done for the later steps, customisation.

The thing to take away from here is "`:focus`" and "`:focus-visible`", I see too often people wiping away inbuilt focus indicators
with css as such as "`outline: none`" DO NOT DO THIS! Or if you are going to do this replace it with some other indicator of focus
this is such a massive let down on the accessibility side and no matter how much your designer tells you that you don't need it
you 100% do. If you cannot tab through your website and use it reliably you are letting people down! In my case I simply create
a custom outline that looks nicer that the bog standard outline.

### Final Step 3: Customisation

Throughout this blog post there have been multiple occurrences in which I have utilised css variables with some quick wins
but nothing too substantial coming from it. This is where it all comes together, this is where we really see the benefits of
css variables and how they play such a key role!

Instead of showing the final demo again I am simply going to highlight ways in which you can customise your buttons, if you
want the full code <Link to="#full-code-example">click here to go to the top</Link> First up is creating a new class to
create a new type of button:

<StepThreeDemo
  demoOne
  code={`
.btn.btn-green {
  --btn-color: #232323;
  --btn-background-color: #5cdb5c;
  --btn-background-color-hover: #7ce27c;
}
  `}
/>
<br />

This is what button perfection looks like in my eyes, you setup your styles in such a way that when you want to have a new
color theme you literally just tell the button what color you want the button to be. The best part is if all you wanted to
do is change the hover color for one button, you would only need to set the one variable and all of the others would default
back to however they are defined!

There is one downside to this approach which is made very obvous by "anchor-btn btn btn-green" this is quite the mouth full
however there is a solution! css preprocessing! The most common of which being sass, in which there are two approaches:

1. define mixins for each of our classes from above, then create single class implementations for each you desire to use.

```scss
@mixin button-btn {
// ...
}
@mixin anchor-btn {
// ...
}
@mixin btn {
// ...
}
@mixin btn-green {
// ...
}

.anchor-btn {
  @include anchor-btn;
  @include btn;
}
.button-btn {
  @include button-btn;
  @include btn;
}
button.btn-green {
  @include button-btn;
  @include btn;
  @include btn-green;
}
button.btn-green {
  @include anchor-btn;
  @include btn;
  @include btn-green;
}
```
<br />

2. using extend: similar to the above, except you just create the btn, button-btn and anchor-btn classes and inside you
simply "`@extend: .btn`" for the "`.button-btn`" and you "`@extend: .button-btn`" for the "`.btn-green`".

do note that the order in which you include or extend does matter! The order is normalise => base button => customisation
it needs to be this way as this is the order in which the css classes are defined in the original example and order when
you are using single class selectors is VERY important because specificity ends up being determined by what was written last
and thus we need to re-create a pseudo specificity effect (when the lower inline styles overwrite the styles above them)
inside of our single class solutions that mimics this.

The next way you can customise your button's appearance is really helpful for once off changes that you want to make quick
and dirty and looks like so:

<StepThreeDemo
  demoTwo
  className="html"
  code={`
<a style="--btn-background-color: #ff0021" />
  `}
/>
<br />

Another cool thing you could do is say you are making a st-patricks day post and you wanted to give the CTA buttons
that are a part of your blog post a special green theme, well you can just place the style tag wit the css variable
on the main/article/div element that wraps your blog post and then automatiaclly all of your buttons become specially
themed! You could also overwrite the entire page's buttons even those outside of your blogpost by defining another "`:root`"
pseudo class, provided it is defined later in the document as the base css styling for your website, it will override all
the buttons on the page! (you could even theme your entire website this way and allow users to easily create their own
themes for your website with this method)

# Wrapping up
<br />

This was quite the lengthy blog post, as I write this I am still deciding if I will split it up into three separate posts
OR if I will just leave it whole (as that is how I would consume it). I really found writing this post super helpful as
I ended up playing around with what I thought a good button was made of and in the process of doing so I one up'd my game.

Prior to this post I defined the text color of a button on the styling class and NOT on the normalisation however after
writing about it, I discovered actually the correct place to fix it is at the normalisation layer to account for pesky css
styles written by other frameworks you may be working with.

I also never used :root to define my css variables and instead I defined them as I used them. However, when I went to
wrap a section of the example (not the button itself) I discovered that cool effect of overwriting the css variable via
inheritance only worked if you pushed the definition all the way up to the root of the document and therefore learnt why
all those pesky modern css frameworks were doing this.

What's next? I plan on writing a follow-up to this piece explaining how I style buttons when I am using css-in-js libraries
as such as emotion and styled-components. I will pull apart the classes from this blog post, turn them into mixins and rather
similar to the sass pre-processing example I will build out my buttons that way. One benifit of using a css-in-js library
however is you can tidy up the inline themeing like so:

```jsx
<button style="--btn-background-color: red"></button>
{/* becomes */}
<Button background"red"></Button>
```

Stay tuned for how exactly all of this is possible!